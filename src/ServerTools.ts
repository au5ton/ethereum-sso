import { recoverPersonalSignature } from 'eth-sig-util'
import { ethers } from 'ethers';
import { v4 as uuidv4 } from 'uuid';
import { generateAffirmationMessage } from './CommonTools';

/** Options which are necessary to validate the signature. */
export interface SignatureValidationOptions {
  /** The address connected to the signature */
  walletAddress: string;
  /** The signature of the claimant */
  signature: string;
  /** Origin to restrict signature to */
  restrictedOrigin: string;
  /** Chain to restrict signature to */
  restrictedChain: number;
  /** Function that maps an Ethereum address to a nonce. Provide your persistent storage solution here. */
  addressToNonceMapper: (address: string) => Promise<string>;
};

/**
 * Used to validate the signature of a public key
 * @param options 
 * @returns 
 */
export async function validateSignature(options: SignatureValidationOptions): Promise<boolean> {
  /**
   * Generates the affirmation message based on the provided wallet address and signature.
   * The nonce is pulled from persistent storage.
   * The restricted chain and origin are (presumably) provided from a config storage (like a file).
   */
  const affirmation_message = await generateAffirmationMessage(await options.addressToNonceMapper(options.walletAddress), options.walletAddress, options.restrictedOrigin, options.restrictedChain);
  /**
   * Estimates that address that was used to create the provided signature.
   * "estimated" because incorrect verifications just give the wrong address, they don't fail
   */
  const estimated_address = recoverPersonalSignature({ data: affirmation_message, sig: options.signature });
  /**
   * Compare the estimated address with the provided wallet address.
   * This is resistant to attack because the nonce is generated by the server and pulled from persistent storage when regenerating the affirmation message.
   */
  return options.walletAddress.toLocaleLowerCase() === estimated_address.toLocaleLowerCase();
}

/**
 * Generates a UUIDv4
 * @returns 
 */
export const generateNonce = () => uuidv4();

export const getProvider = ethers.getDefaultProvider;
